package nz.ac.canterbury.seng302.gardenersgrove.service;

import nz.ac.canterbury.seng302.gardenersgrove.controller.UserController;
import nz.ac.canterbury.seng302.gardenersgrove.dto.ForgotPasswordDTO;
import nz.ac.canterbury.seng302.gardenersgrove.dto.ResetPasswordDTO;
import nz.ac.canterbury.seng302.gardenersgrove.entity.User;
import nz.ac.canterbury.seng302.gardenersgrove.exception.ValidationException;
import nz.ac.canterbury.seng302.gardenersgrove.repository.VerificationTokenRepository;
import nz.ac.canterbury.seng302.gardenersgrove.validation.ImageValidator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.validation.BindingResult;
import org.springframework.web.multipart.MultipartFile;

import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Objects;


/**
 * The user authentication service. Authenticates users for login, registration, and edit.
 */
@Service
public class UserAuthenticationService {
    Logger logger = LoggerFactory.getLogger(UserController.class);
    private final AuthenticationManager authenticationManager;
    private final UserService userService;
    private final PasswordEncoder passwordEncoder;
    private final VerificationTokenRepository tokenRepository;
    private static final String PASSWORD_ERROR_FIELD = "password";

    /**
     * The constructor for the user authentication service
     */
    @Autowired
    public UserAuthenticationService(UserService userService, AuthenticationManager authenticationManager, PasswordEncoder passwordEncoder, VerificationTokenRepository tokenRepository) {
        this.userService = userService;
        this.authenticationManager = authenticationManager;
        this.passwordEncoder = passwordEncoder;
        this.tokenRepository = tokenRepository;
    }

    /**
     * Checks if the email is of valid format
     *
     * @param email Users email
     */
    private void checkEmailValid(String email) throws ValidationException {

        // Checks if email is valid - Regex generated by Chat-GPT
        if (email == null || !email.matches("^[a-zA-Z0-9][a-zA-Z0-9._%+-]*@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)+$")) {
            throw new ValidationException("email", 401, "Email address must be in the form 'jane@doe.nz'");
        }
    }

    /**
     * Checks if the dob is valid
     *
     * @param dob Users date of birth
     */
    private void checkDobValid(String dob) throws ValidationException {

        if (dob == null || dob.isEmpty()) {
            return;
        }
        // Declare variables
        LocalDate dateOfBirth;
        LocalDate today;

        // Setup date variables and check for null values
        try {
            dateOfBirth = LocalDate.parse(dob, DateTimeFormatter.ISO_DATE);
            today = LocalDate.now();
        } catch (Exception e) {
            throw new ValidationException("dob", 401, "Date is not in valid format, DD/MM/YYYY");
        }

        //Checks that dob is not null
        if (dateOfBirth.isAfter(today.minusYears(13))) {
            throw new ValidationException("dob", 401, "You must be 13 years or older to create an account");
            // Checks if dob is too late
        } else if (dateOfBirth.isBefore(today.minusYears(121)) || dateOfBirth.isEqual(today.minusYears(121))) {
            throw new ValidationException("dob", 401, "The maximum age allowed is 120 years");
        }
    }

    /**
     * Checks if the first name is valid
     *
     * @param firstName Users first name
     */
    private void checkFirstNameValid(String firstName) throws ValidationException {

        // Check for an empty or invalid first name
        if (firstName == null || firstName.isBlank() || firstName.matches("^([-']{1,2}|[ ]{1,2}|[\n\t])$") || !firstName.matches("^[a-zA-ZÀ-ÖØ-öø-ÿĀĒĪŌŪāēīōū\\s'-]+$")) {
            throw new ValidationException("firstName", 401, "First name cannot be empty and must only include letters, spaces, hyphens or apostrophes");

            //Checks that first name is less than 64 characters long (including 64)
        } else if (firstName.length() > 64) {
            throw new ValidationException("firstName", 401, "First name must be 64 characters long or less");
        }
    }

    /**
     * Checks if the last name is valid
     *
     * @param lastName   Users last name
     * @param noLastName User last name true/false
     */
    private void checkLastNameValid(String lastName, boolean noLastName) throws ValidationException {

        // Check for an empty or invalid last name if noLastName is set false (user has last name)
        if (!noLastName && (lastName == null || lastName.isBlank() || lastName.matches("^([-']{1,2}|[ ]{1,2}|[\n\t])$") ||!lastName.matches("^[a-zA-ZÀ-ÖØ-öø-ÿĀĒĪŌŪāēīōū\\s'-]+$"))) {
            throw new ValidationException("lastName", 401, "Last name cannot be empty and must only include letters, spaces, hyphens or apostrophes");

            // Checks that last name is less than 64 characters long (including 64) if noLastName is set false (user has last name)
        } else if (!noLastName && lastName.length() > 64) {
            throw new ValidationException("lastName", 401, "Last name must be 64 characters long or less");
        }
        // No checks if the user set noLastName to true
    }

    /**
     * Checks password is secure
     *
     * @param password Users password
     */
    private void checkPasswordSecure(String password) throws ValidationException {

        // Check password
        if (password == null ||
                password.length() < 8 ||                          // At least eight characters
                !password.matches(".*[a-z].*") ||       // At least one lowercase letter
                !password.matches(".*[A-Z].*") ||       // At least one uppercase letter
                !password.matches(".*\\d.*") ||         // At least one digit
                !password.matches(".*[^a-zA-Z\\d].*")) {// At least one special character

            throw new ValidationException(PASSWORD_ERROR_FIELD, 401, "Your password must be at least 8 characters long and include at least one uppercase letter, one lowercase letter, one number, and one special character.");
        }
    }

    /**
     * Checks if passwords match
     *
     * @param password1 First password enetered
     * @param password2 Second password entered
     */
    private void checkPasswordsMatch(String password1, String password2) throws ValidationException {

        // Check if passwords match
        if (!password1.equals(password2)) {
            throw new ValidationException("passwordRepeat", 401, "Passwords do not match");
        }
    }

    /**
     * Checks if new passwords match
     * @param password1 First password entered
     * @param password2 Second password entered
     */
    private void checkNewPasswordsMatch(String password1, String password2) throws ValidationException {

        // Check if passwords match
        if (!password1.equals(password2)) {
            throw new ValidationException("passwordRepeat", 401, "The new passwords do not match");
        }
    }

    /**
     * Checks if the email already in use
     *
     * @param email Users email
     */
    private void checkEmailNotRegistered(String email) throws ValidationException {

        User existingUser = userService.getUserByEmail(email);

        // If the email is not already in use
        if (existingUser != null) {
            // If the user exists and has confirmed an account
            if (existingUser.getEnabled()) {
                throw new ValidationException("email", 401, "This email address is already in use");
            }
            // If a non-authenticated email with a live token is being re-registered, don't allow
            if (!existingUser.getEnabled() && !tokenRepository.findByUser(existingUser).hasExpired()) {
                throw new ValidationException("email", 401, "This email address is already in use");
            }
            // If the non-authenticate email has an expired token, that email will be deleted when this check is called
            if (!existingUser.getEnabled() && tokenRepository.findByUser(existingUser).hasExpired()) {
                userService.removeUser(existingUser);
            }
        }
    }

    /**
     * Checks the username and password
     *
     * @param email    the email entered
     * @param password the plain text password entered
     */
    private void checkEmailAndPassword(String email, String password) throws ValidationException {

        // Get the user associated with the email
        User user = userService.getUserByEmail(email);

        // Check to see if email is valid if so check password otherwise throw error
        if (user == null || !passwordEncoder.matches(password, user.getPassword())) {
            throw new ValidationException(PASSWORD_ERROR_FIELD, 401, "The email address is unknown, or the password is invalid");
        }

        if (!user.getEnabled()) {
            throw new ValidationException(PASSWORD_ERROR_FIELD, 401, "Please confirm your email address");
        }

        // Check for a blocked user only if password correct and account enabled
        checkIsBlocked(user.getEmail());
    }

    /**
     * Check if the users account has been blocked.
     * Also checks time to see if a ban has expired.
     *
     * @param email                 the email
     * @throws ValidationException  the error message
     */
    private void checkIsBlocked(String email) throws ValidationException {
        // Get the user associated with the email
        User user = userService.getUserByEmail(email);

        // Check is the user is blocked
        if (user != null && user.isBlocked()) {

            // Get the days blocked for
            Duration duration = Duration.between(LocalDateTime.now(), user.getBlockedEndDate());

            // Get times for string formatting
            long days = duration.toDays();
            long hours = duration.toHours() % 24;

            // Check for valid ban duration
            if (!duration.isNegative() && !duration.isZero()) {
                throw new ValidationException(PASSWORD_ERROR_FIELD, 401, String.format("Account is blocked for %d days, %d hours", days, hours));
            } else {
                // Reset time if ban has expired
                user.setBlocked(false);
                user.setBlockedEndDate(null);
                user.resetInappropriateWarningCount();
                userService.updateUser(user);
            }
        }
    }

    /**
     * Checks the password entered matches the old password
     *
     * @param user        the current user
     * @param oldPassword the old password entered
     */
    private void checkOldPassword(User user, String oldPassword) throws ValidationException {
        // Check to see if password is valid otherwise throw error
        if (!passwordEncoder.matches(oldPassword, user.getPassword())) {
            throw new ValidationException("oldPassword", 401, "Your old password is incorrect");
        }
    }

    /**
     * Checks if the user did not enter on old passsword
     * @param oldPassword the old password entered
     */
    private void checkNoOldPassword(String oldPassword) throws ValidationException {
        // Check to see if the old password field is empty
        if (oldPassword.isEmpty() || oldPassword == null) {
            throw new ValidationException("oldPassword", 401, "Please enter your old password or press cancel to exit");
        }
    }

    /**
     * Check that the submitted profile image is valid and update in the database for current users profile image
     * @param user that profile image belongs to and should change
     */
    public void authenticateUserEditProfileImage(User user) throws ValidationException {
        // Only check if image is present
        if (user.getProfileImage() != null && !user.getProfileImage().isEmpty()) {
            checkImageValid(user.getProfileImage());
        }

        // Update user in database
        User newUser = userService.editUser(user);

        // Authenticate
        SecurityContextHolder.clearContext();
        authenticateUser(newUser);
    }


    /**
     * Checks if the image is valid
     * @param image the image uploaded
     * @throws ValidationException if the image is invalid
     */
    private void checkImageValid(MultipartFile image) throws ValidationException {
        if (!ImageValidator.isImageTypeCorrect(image)) {
            throw new ValidationException("profileImage", 401, "Image must be of type png, jpg or svg");
        }
        if (!ImageValidator.isImageSizeValid(image)) {
            throw new ValidationException("profileImage", 401, "Image must be less than 10MB");
        }
    }

    /**
     * Checks that a token is valid
     *
     * @param token The users token
     * @throws ValidationException if invalid
     */
    public void checkTokenValid(String token) throws ValidationException {

        // Get the user by token
        User user = userService.getUserByToken(token);

        // Check if token doesn't exist or expired
        if (user == null || user.getTokenExpiry().isBefore(LocalDateTime.now())) {
            throw new ValidationException("token", 401, "The token is invalid or expired");
        }
    }

    /**
     * Checks if user is valid, if a field is invalid, add an error to the bindingResult
     *
     * @param user the user being validated
     * @param bindingResult object used to store the errors
     * @return the bindingResult containing the errors found
     */
    public BindingResult authenticateUserRegister(User user, BindingResult bindingResult) {

        try {
            checkEmailValid(user.getEmail());
        } catch (ValidationException e) {
            bindingResult.rejectValue(e.getField(), e.getErrorCode(), e.getMessage());
        }try {
            checkEmailNotRegistered(user.getEmail());
        } catch (ValidationException e) {
            bindingResult.rejectValue(e.getField(), e.getErrorCode(), e.getMessage());
        }
        try {
            checkDobValid(user.getDob());
        } catch (ValidationException e) {
            bindingResult.rejectValue(e.getField(), e.getErrorCode(), e.getMessage());
        }
        try {
            checkFirstNameValid(user.getFirstName());
        } catch (ValidationException e) {
            bindingResult.rejectValue(e.getField(), e.getErrorCode(), e.getMessage());
        }
        try {
            checkLastNameValid(user.getLastName(), user.getNoLastName());
        } catch (ValidationException e) {
            bindingResult.rejectValue(e.getField(), e.getErrorCode(), e.getMessage());
        }
        try {
            checkPasswordSecure(user.getPassword());
            checkPasswordsMatch(user.getPassword(), user.getPasswordRepeat());
        } catch (ValidationException e) {
            bindingResult.rejectValue(e.getField(), e.getErrorCode(), e.getMessage());

        }
        return bindingResult;
    }

    /**
     * Registers a user for the first time
     * @param user the user to be registered
     * @return the registered user
     */
    public User registerUser(User user) {
        // Add authority to user
        user.grantAuthority("ROLE_USER");

        // Add user to database
        userService.addUser(user);

        // Authenticate the user
        authenticateUser(user);

        return user;
    }

    /**
     * For login validation.
     * Checks email, password, and blocked accounts.
     *
     * @param user The user to be authenticated
     * @param bindingResult Stores the errors
     * @return bindingResult with the found errors
     */
    public BindingResult authenticateUserLogin(User user, BindingResult bindingResult) {

        try {
            checkEmailValid(user.getEmail());
        } catch (ValidationException e) {
            bindingResult.rejectValue(e.getField(), e.getErrorCode(), e.getMessage());
        }

        try {
            checkEmailAndPassword(user.getEmail(), user.getPassword());
        } catch (ValidationException e) {
            bindingResult.rejectValue(e.getField(), e.getErrorCode(), e.getMessage());
        }

        return bindingResult;
    }

    /**
     * Logs in a given user
     * @param user the user being logged in
     */
    public void logInUser(User user) {
        // Authenticate the user (gets the actual user from database for authorities)
        authenticateUser(userService.getUserByEmail(user.getEmail()));
    }

    /**
     * Checks if user is valid and authenticates them
     *
     * @param user the user object
     */
    public BindingResult authenticateUserEdit(User user, BindingResult bindingResult) {

        // Only check if image is present
        if (user.getProfileImage() != null && !user.getProfileImage().isEmpty()) {
            try {
                checkImageValid(user.getProfileImage());
            } catch (ValidationException e) {
                bindingResult.rejectValue(e.getField(), e.getErrorCode(), e.getMessage());
            }
        }

        try {
            checkEmailValid(user.getEmail());
        } catch (ValidationException e) {
            bindingResult.rejectValue(e.getField(), e.getErrorCode(), e.getMessage());
        }
        // Only check email if different to current users
        if (!Objects.equals(user.getEmail(), userService.getCurrentUser().getEmail())) {
            try {
                checkEmailNotRegistered(user.getEmail());
            } catch (ValidationException e) {
                bindingResult.rejectValue(e.getField(), e.getErrorCode(), e.getMessage());
            }
        }

        try {
            checkDobValid(user.getDob());
        } catch (ValidationException e) {
            bindingResult.rejectValue(e.getField(), e.getErrorCode(), e.getMessage());
        }

        try {
            checkFirstNameValid(user.getFirstName());
        } catch (ValidationException e) {
            bindingResult.rejectValue(e.getField(), e.getErrorCode(), e.getMessage());
        }

        try {
            checkLastNameValid(user.getLastName(), user.getNoLastName());
        } catch (ValidationException e) {
            bindingResult.rejectValue(e.getField(), e.getErrorCode(), e.getMessage());
        }

        try {
            // Only check password if one entered
            if (user.getPassword() != null && !user.getPassword().isEmpty()) {
                checkPasswordSecure(user.getPassword());
                checkPasswordsMatch(user.getPassword(), user.getPasswordRepeat());
            }
        }
        catch (ValidationException e) {
            bindingResult.rejectValue(e.getField(), e.getErrorCode(), e.getMessage());
        }

        return bindingResult;
    }

    /**
     * Edits a given user in the database
     * @param user the user being edited
     */
    public void editUser(User user) {
        // Update user in database
        User newUser = userService.editUser(user);

        // Authenticate
        SecurityContextHolder.clearContext();
        authenticateUser(newUser);
    }

    /**
     * Checks if users new password is valid
     * @param user the user object
     */
    public BindingResult authenticateUserEditPassword(User user, String oldPassword, BindingResult bindingResult) {
        //Current user
        User currentUser = userService.getCurrentUser();

        // Check passwords are valid
        try {
            checkNoOldPassword(oldPassword);
            checkOldPassword(currentUser, oldPassword);
        } catch (ValidationException e) {
            bindingResult.rejectValue(e.getField(), e.getErrorCode(), e.getMessage());
        }
        try {
            checkPasswordSecure(user.getPassword());
        } catch (ValidationException e) {
            bindingResult.rejectValue(e.getField(), e.getErrorCode(), e.getMessage());
        }
        try {
            checkNewPasswordsMatch(user.getPassword(), user.getPasswordRepeat());
        } catch (ValidationException e) {
            bindingResult.rejectValue(e.getField(), e.getErrorCode(), e.getMessage());
        }
        return bindingResult;
    }

    /**
     * Adds the users new password and authenticates them
     * @param user the user object
     */
    public User editUserPassword(User user) {
        // Update user in database
        User newUser = userService.editUserPassword(user);

        user.grantAuthority("ROLE_USER");

        // Add user to database
        User editedUser = userService.editUserPassword(user);

        // Authenticate the user
        authenticateUser(editedUser);

        return editedUser;
    }

    /**
     * Validates the forgot password. Then calls function to send email about reset password.
     * @param forgotPasswordDTO The forgot password DTO (containing email)
     */
    public User authenticateForgotPassword(ForgotPasswordDTO forgotPasswordDTO) throws ValidationException {
        // Check the email is valid
        checkEmailValid(forgotPasswordDTO.getEmail());

        // Send reset password function
        return userService.forgotPassword(forgotPasswordDTO);
    }

    /**
     * Validates the reset password. Then calls function to reset password.
     * @param resetPasswordDTO The reset password DTO
     */
    public User authenticateResetPassword(ResetPasswordDTO resetPasswordDTO) throws ValidationException {
        // Check token exists
        checkTokenValid(resetPasswordDTO.getToken());

        // Run validation checks on passwords
        checkPasswordSecure(resetPasswordDTO.getPassword());
        checkPasswordsMatch(resetPasswordDTO.getPassword(), resetPasswordDTO.getPasswordRepeat());

        // Reset the password
        User user = userService.resetPassword(resetPasswordDTO);

        // Authenticate
        SecurityContextHolder.clearContext();
        authenticateUser(user);
        return user;
    }

    /**
     * Authenticates the user and keeps state
     *
     * @param user The user being authenticated
     */
    private void authenticateUser(User user) {

        // Authenticate the user token with the CustomAuthenticationProvider
        Authentication authentication = authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(user.getEmail(), user.getPassword(), user.getAuthorities()));

        // Add the authentication to the current security context
        SecurityContextHolder.getContext().setAuthentication(authentication);
    }
}